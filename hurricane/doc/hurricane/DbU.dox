
 // -*- C++ -*-


 namespace Hurricane {

 /*! \defgroup     DbUGroup  DbU/Unit description
  *
  *  \section      secDbUIntro  Introduction
  *
  *                The DbU class provides the DbU::Unit type for modelling geometric
  *                length, that is abscissas, ordinates, widths, offsets and a set of
  *                functions to convert DbU::Unit to and from external coordinates.
  *
  *  \remark       The DbU class contains only static methods, and is not meant to
  *                be instanciated. The working type is DbU::Unit.
  *
  *                The DbU class manage three king of length :
  *                <ul>
  *                  <li><b>DbU::Unit</b> : the working type. It is currently associated
  *                      to a long integer and a precision/resolution. This way all
  *                      numbers are bound to the same precision (unlike floating
  *                      point numbers) preventing rounding errors.
  *                  <li><b>Real</b> length : length, expressed in steps of founder
  *                      grid. We have the straight relation ship :
  *                          grid = unit * resolution 
  *                  <li><b>Symbolic</b> length : length, expressed in lambdas.
  *                      A lambda is an even multiple of the founder grid step.
  *                          lambda = grid / lambdaPerGrid
  *                </ul>
  * 
  *  \section      secDbUPrecision  Precision
  *
  *                It is possible to choose (once for all) the precision with 
  *                which unit values are stored. 
  *
  *                This precision represents the maximal number of decimal 
  *                digits allowed (it applies globally to all units). Therefore 
  *                for a precision of 3, the unit will represent a value of 
  *                0.001 and the founder grid value 23.54 will be represented by a 
  *                unit equal to 23540. 
  *
  *                Related functions :
  *                <ul>
  *                  <li><b>DbU::getPrecision()</b>
  *                  <li><b>DbU::getMaximalPrecision()</b>
  *                  <li><b>DbU::setPrecision()</b>
  *                </ul>
  * 
  * 
  *  \section      secDbUResolution  Resolution
  *
  *                The resolution is associated to the precision. Indeed it 
  *                represents the external value associated to the smallest 
  *                unit, that is the value returned by getReal(Unit::db(1)). 
  *
  *                Related functions :
  *                <b>DbU::getResolution()</b>
  *
  *  \section      secDbURealsPerLamba  Reals per Lambda ratio
  *
  *                Set the ratio between reals and lambdas. This must be an
  *                even integer. Once sets, musn't be changed.
  *
  *                Related functions :
  *                <ul>
  *                  <li><b>DbU::setRealsPerLambda()</b>
  *                  <li><b>DbU::getRealsPerLambda()</b>
  *                </ul>
  * 
  * 
  *  \section      secDbUGrid  Grid
  *
  *                <ul>
  *                  <li><b>DbU::getGridStep</b>
  *                  <li><b>DbU::setGridStep</b>
  *                  <li><b>DbU::isOnGrid</b>
  *                  <li><b>DbU::getOnGridUnit</b>
  *                </ul>
  * 
  * 
  *  \section      secDbUTranslators  Translators
  *
  *                Translate a DbU::Unit into grid or lambda length :
  *                <ul>
  *                  <li><b>long   DbU::getDb    (DbU::Unit u)</b>
  *                  <li><b>double DbU::getReal  (DbU::Unit u)</b>
  *                  <li><b>double DbU::getLambda(DbU::Unit u)</b>
  *                </ul>
  *
  *                Translate a lambda length into a DbU::Unit :
  *                <ul>
  *                  <li><b>DbU::Unit DbU::db(long u)</b>
  *                  <li><b>DbU::Unit DbU::real(double u)</b>
  *                  <li><b>DbU::Unit DbU::lambda(double u)</b>
  *                </ul>
  */



 /*! \ingroup      DbUGroup
  */
 //  \{

 /*! \class        DbU
  *  \brief        DataBase Unit managment (\b API).
  *
  *                <b>Explanations about this class are here \ref DbUGroup.</b>
  */

 /*  \function     bool DbU::isOnGrid(const Unit& unit, int n = 1);
  *  \Return       \true if the unit is on grid, else \false. The argument 
  *                \c \<n\> allows to consider on grid only multiples of 
  *                \c \<n\> grid steps. So if n=1 all grid steps are considered, 
  *                but if n=2 only even grid steps are considered. 
  */


 /*! \typedef      long  DbU::Unit;
  *                The working DataBase type for storing dimensions.
  */

 /*! \enum         DbU::StringMode
  *                Select how units are to be printed by getValueString().
  */
 /*! \var          Dbu::StringMode DbU::Db
  *                Units are printed "as is", their true value as stored in the
  *                DataBase.
  */
 /*! \var          Dbu::StringMode DbU::Real
  *                Units are printed as real (founder grid steps).
  */
 /*! \var          Dbu::StringMode DbU::Symbolic
  *                Units are printed as symbolic (lambdas).
  */

 /*! \function     unsigned DbU::getPrecision();
  *  \Return       the current precision (whose default is fixed to 1). 
  */

 /*! \function     unsigned DbU::getMaximalPrecision();
  *  \Return       the maximal precision allowed (currently fixed to 3). 
  */

 /*! \function     double DbU::getResolution();
  *  \Return       the current resolution. 
  */

 /*  \function     const DbU::Unit& DbU::getGridStep();
  *  \Return       the grid step. 
  */

 /*  \function     DbU::Unit DbU::getOnGridUnit(const Unit& unit, int s = 0);
  *  \Return       the closest location on grid if the argument \c \<s\> equals 
  *                0, the closest inferior location on grid if the argument 
  *                \c \<s\> equals -1 and the closest superior location on grid 
  *                if the argument \c \<s\> equals +1. 
  *
  *  \remark       Throw an exception for any other \c \<s\> argument value. 
  */

 /*! \function     void  DbU::setRealsPerLambda(double realsPerLambda);
  *  \Return       Sets how many reals (founder grid steps) makes one <i>lambda</i>.
  *                It must be an event integer otherwise an exception is thrown.
  */

 /*! \function     double  DbU::getRealsPerLambda();
  *  \Return       How many reals (founder grid steps) makes one <i>lambda</i>.
  */

 /*! \function     DbU::Unit DbU::db(long u);
  *  \Return       the unit corresponding to the value \c \<value\> according to 
  *                the current precision. This function do nothing apart from a
  *                cast.
  */

 /*! \function     DbU::Unit DbU::real(double value);
  *  \Return       the unit corresponding to the <i>real</i> value \c \<value\>
  *                according to the current precision.
  */

 /*! \function     DbU::Unit DbU::lambda(double value);
  *  \Return       the unit corresponding to the <i>symbolic</i> value \c \<value\>
  *                according to the current precision.
  */

 /*! \function     long DbU::getDb(Unit unit);
  *  \Return       the external value associated to the unit \c \<unit\> 
  *                according to the current precision. This function do
  *                nothing apart from a type cast.
  */

 /*! \function     double DbU::getReal(Unit unit);
  *  \Return       the real value (expressed as a number of founder grid steps)
  *                associated to the unit \c \<unit\> according to the current
  *                precision.
  */

 /*! \function     double DbU::getLambda(Unit unit);
  *  \Return       the symbolic value (expressed as a number lambdas)
  *                associated to the unit \c \<unit\> according to the current
  *                precision.
  */

 /*! \function     void DbU::setStringMode(unsigned int mode);
  *                Sets in which length the units are to be displayed by
  *                getValueString(). Avalaibles modes are :
  */

 /*! \function     string DbU::getValueString(Unit  unit);
  *  \return       A character string representing the external value of 
  *                \c \<unit\>. The value is converted in the length according
  *                to setStringMode(): database, real or symbolic.
  *
  *  \remark       This string is shorter than the one we could print from the 
  *                external value because non needed decimals are not drawn (nor 
  *                the point if value is integer). 
  */

 /*! \function     void DbU::setPrecision(unsigned int precision);
  *                Allows to set the precision at a requested value. This must 
  *                be done at the begining of the program (before the creation 
  *                of the first unit) and not changed for the following (unless 
  *                mandatory and for a temporary period because all existing 
  *                units would be misinterpreted). 
  *
  *  \remark       This function throws an exception if the requested precision 
  *                is greater than the maximal one. 
  */

 /*  \function     void DbU::setGridStep(const Unit& gridStep);
  *                Allows to change the grid step. 
  */

 //  \}

 }
