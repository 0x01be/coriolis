
 // -*- C++ -*-


 namespace Hurricane {

 /*! \defgroup     DbU  DbU/Unit description
  *
  *  \section      secDbUIntro  Introduction
  *
  *                Those objects are used to model a geometric lengths, that is 
  *                abscissas, ordinates, widths, offsets ... 
  *
  *                They are represented internally by a <b>long integer</b> 
  *                asociated with a <b>precision</b> and not by a double in 
  *                order to avoid floating point round errors. 
  * 
  * 
  *  \section      secDbUPrecision  Precision
  *
  *                It is possible to choose (once for all) the precision with 
  *                which unit values are stored. 
  *
  *                This precision represents the maximal number of decimal 
  *                digits allowed (it applies globally to all units). Therefore 
  *                for a precision of 3, the unit will represent a value of 
  *                0.001 and the effective value 23.54 will be represented by a 
  *                unit equal to 23540. 
  *
  *                <ul>
  *                  <li><b>DbU::getPrecision</b>
  *                  <li><b>DbU::getMaximalPrecisionAllowed</b>
  *                  <li><b>DbU::setPrecision</b>
  *                </ul>
  * 
  * 
  *  \section      secDbUResolution  Resolution
  *
  *                The resolution is associated to the precision. Indeed it 
  *                represents the external value associated to the smallest 
  *                unit, that is the value returned by getValue(getUnit(1)). 
  *
  *                <b>DbU::getResolution</b>
  * 
  * 
  *  \section      secDbUGrid  Grid
  *
  *                <ul>
  *                  <li><b>DbU::getGridStep</b>
  *                  <li><b>DbU::setGridStep</b>
  *                  <li><b>DbU::isOnGrid</b>
  *                  <li><b>DbU::getOnGridUnit</b>
  *                </ul>
  * 
  * 
  *  \section      secDbUTranslators  Translators
  *
  *                <ul>
  *                  <li><b>DbU::getUnit</b>
  *                  <li><b>DbU::getValue</b>
  *                  <li><b>DbU::getValueString</b>
  *                </ul>
  */



 /*! \ingroup      DbU
  */
 //  \{

 /*  \function     bool DbU::isOnGrid(const Unit& unit, int n = 1);
  *  \Return       \true if the unit is on grid, else \false. The argument 
  *                \c \<n\> allows to consider on grid only multiples of 
  *                \c \<n\> grid steps. So if n=1 all grid steps are considered, 
  *                but if n=2 only even grid steps are considered. 
  */


 /*  \function     unsigned DbU::getPrecision();
  *  \Return       the current precision (whose default is fixed to 0). 
  */

 /*  \function     unsigned DbU::getMaximalPrecisionAllowed();
  *  \Return       the maximal precision allowed (currently fixed to 3). 
  */

 /*  \function     double DbU::getResolution();
  *  \Return       the current resolution. 
  */

 /*  \function     const DbU::Unit& DbU::getGridStep();
  *  \Return       the grid step. 
  */

 /*  \function     DbU::Unit DbU::getOnGridUnit(const Unit& unit, int s = 0);
  *  \Return       the closest location on grid if the argument \c \<s\> equals 
  *                0, the closest inferior location on grid if the argument 
  *                \c \<s\> equals -1 and the closest superior location on grid 
  *                if the argument \c \<s\> equals +1. 
  *
  *  \remark       Throw an exception for any other \c \<s\> argument value. 
  */

 /*  \function     DbU::Unit getUnit(double value);
  *  \Return       the unit corresponding to the value \c \<value\> according to 
  *                the current precision. 
  */

 /*  \function     double DbU::getValue(const Unit& unit);
  *  \Return       the external value associated to the unit \c \<unit\> 
  *                according to the current precision. 
  */

 /*  \function     string DbU::getValueString(const Unit& unit);
  *  \Return       a character string representing the external value of 
  *                \c \<unit\>. 
  *
  *  \remark       This string is shorter than the one we could print from the 
  *                external value because non needed decimals are not drawn (nor 
  *                the point if value is integer). 
  */


 /*  \function     void DbU::setPrecision(unsigned precision);
  *                Allows to set the precision at a requested value. This must 
  *                be done at the begining of the program (before the creation 
  *                of the first unit) and not changed for the following (unless 
  *                mandatory and for a temporary period because all existing 
  *                units would be misinterpreted). 
  *
  *  \remark       This function throws an exception if the requested precision 
  *                is greater than the maximal one. 
  */

 /*  \function     void DbU::setGridStep(const Unit& gridStep);
  *                Allows to change the grid step. 
  */

 //  \}

 }
