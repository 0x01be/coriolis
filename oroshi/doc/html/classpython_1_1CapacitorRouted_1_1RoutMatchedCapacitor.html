<!DOCTYPE HTML PUBLIC '-//W3C//DTD HTML 4.0//EN'>
<html>
  <head>
    <meta http-equiv="Content-Type" content="text/html;charset=iso-8859-1">
    <title>Oroshi Documentation</title>
    <script type="text/javascript" src="jquery.js"></script>
    <script type="text/javascript" src="dynsections.js"></script>
    <link   href="SoC.css" rel="stylesheet" type="text/css">
    <link   href="tabs.css" rel="stylesheet" type="text/css">
  </head>
    <h1 id="pagetop" class="header">Oroshi - Analog Devices Layouts</h1>
    <!--
    <center class="header">
      <table class="header">
        <tr>
          <td><a href="customSummary.html">Summary</a></td>
          <td><a href="namespaces.html">Namespaces</a></td>
          <td><a href="customHierarchy.html">Class Hierarchy</a></td>
          <td><a href="annotated.html">Classes</a></td>
          <td><a href="functions.html">Member Index</a></td>
        </tr>
      </table>
    </center>
    -->
    <br>
  <body onload="javascript:toggleLevel(1)">
<!-- Generated by Doxygen 1.8.5 -->
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li class="current"><a href="annotated.html"><span>Classes</span></a></li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="annotated.html"><span>Class&#160;List</span></a></li>
      <li><a href="classes.html"><span>Class&#160;Index</span></a></li>
      <li><a href="functions.html"><span>Class&#160;Members</span></a></li>
    </ul>
  </div>
<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><b>python</b></li><li class="navelem"><b>CapacitorRouted</b></li><li class="navelem"><a class="el" href="classpython_1_1CapacitorRouted_1_1RoutMatchedCapacitor.html">RoutMatchedCapacitor</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="classpython_1_1CapacitorRouted_1_1RoutMatchedCapacitor-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">RoutMatchedCapacitor Class Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>Routs two matched capacitors, C1 and C2, drawn in a capacitor matrix.  
 <a href="classpython_1_1CapacitorRouted_1_1RoutMatchedCapacitor.html#details">More...</a></p>

<p>Inherits CapacitorUnit, CapacitorStack, and VerticalRoutingTracks.</p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:ac775ee34451fdfa742b318538164070e"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpython_1_1CapacitorRouted_1_1RoutMatchedCapacitor.html#ac775ee34451fdfa742b318538164070e">__init__</a></td></tr>
<tr class="memdesc:ac775ee34451fdfa742b318538164070e"><td class="mdescLeft">&#160;</td><td class="mdescRight">A special method used to customize the class instance to an initial state in which :  <a href="#ac775ee34451fdfa742b318538164070e">More...</a><br/></td></tr>
<tr class="separator:ac775ee34451fdfa742b318538164070e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a15ec3e3156133327b307cd0e4b75f22c"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpython_1_1CapacitorRouted_1_1RoutMatchedCapacitor.html#a15ec3e3156133327b307cd0e4b75f22c">route</a></td></tr>
<tr class="memdesc:a15ec3e3156133327b307cd0e4b75f22c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Draws the complete layout given the capacitor matrix.  <a href="#a15ec3e3156133327b307cd0e4b75f22c">More...</a><br/></td></tr>
<tr class="separator:a15ec3e3156133327b307cd0e4b75f22c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3b578035b1559391931dade7c2508105"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpython_1_1CapacitorRouted_1_1RoutMatchedCapacitor.html#a3b578035b1559391931dade7c2508105">setRules</a></td></tr>
<tr class="memdesc:a3b578035b1559391931dade7c2508105"><td class="mdescLeft">&#160;</td><td class="mdescRight">Defines technology rules used to draw the layout.  <a href="#a3b578035b1559391931dade7c2508105">More...</a><br/></td></tr>
<tr class="separator:a3b578035b1559391931dade7c2508105"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae361a87f8ad999bb5f1b9851773f481b"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpython_1_1CapacitorRouted_1_1RoutMatchedCapacitor.html#ae361a87f8ad999bb5f1b9851773f481b">setLayers</a></td></tr>
<tr class="memdesc:ae361a87f8ad999bb5f1b9851773f481b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Defines all physical layers used to draw the layout.  <a href="#ae361a87f8ad999bb5f1b9851773f481b">More...</a><br/></td></tr>
<tr class="separator:ae361a87f8ad999bb5f1b9851773f481b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a20b46b43488cc58c302b123a89299d85"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpython_1_1CapacitorRouted_1_1RoutMatchedCapacitor.html#a20b46b43488cc58c302b123a89299d85">computeDimensions</a></td></tr>
<tr class="memdesc:a20b46b43488cc58c302b123a89299d85"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes, through simple instructions and functions calls, layout variables detailed in Figure 2.  <a href="#a20b46b43488cc58c302b123a89299d85">More...</a><br/></td></tr>
<tr class="separator:a20b46b43488cc58c302b123a89299d85"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab00cae047369eb93c10e44e316fa991b"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpython_1_1CapacitorRouted_1_1RoutMatchedCapacitor.html#ab00cae047369eb93c10e44e316fa991b">computeHRoutingTrackYCenter</a></td></tr>
<tr class="memdesc:ab00cae047369eb93c10e44e316fa991b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes centers' ordinates of the eight horizontal routing tracks.  <a href="#ab00cae047369eb93c10e44e316fa991b">More...</a><br/></td></tr>
<tr class="separator:ab00cae047369eb93c10e44e316fa991b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0d90b75abe0f4ce0f0b9b1b405462300"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpython_1_1CapacitorRouted_1_1RoutMatchedCapacitor.html#a0d90b75abe0f4ce0f0b9b1b405462300">computeHRLayerYCenter</a></td></tr>
<tr class="memdesc:a0d90b75abe0f4ce0f0b9b1b405462300"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the stretching value of top plates.  <a href="#a0d90b75abe0f4ce0f0b9b1b405462300">More...</a><br/></td></tr>
<tr class="separator:a0d90b75abe0f4ce0f0b9b1b405462300"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afbe39494b52b035fe3efdb0ddb896f69"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpython_1_1CapacitorRouted_1_1RoutMatchedCapacitor.html#afbe39494b52b035fe3efdb0ddb896f69">drawHRoutingTracks</a></td></tr>
<tr class="memdesc:afbe39494b52b035fe3efdb0ddb896f69"><td class="mdescLeft">&#160;</td><td class="mdescRight">Iteratively draws horizontal routing tracks on top and bottom positions of the matrix using physical layer <code>routingTracksLayer</code>.  <a href="#afbe39494b52b035fe3efdb0ddb896f69">More...</a><br/></td></tr>
<tr class="separator:afbe39494b52b035fe3efdb0ddb896f69"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6bba48a4b1d4834c6617a5af5553be1c"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpython_1_1CapacitorRouted_1_1RoutMatchedCapacitor.html#a6bba48a4b1d4834c6617a5af5553be1c">drawHRLayers</a></td></tr>
<tr class="memdesc:a6bba48a4b1d4834c6617a5af5553be1c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Iteratively draws the horizontal routing layers starting with bottom left elementary capacitor <img class="formulaInl" alt="$ C_{00} $" src="form_15.png"/>.  <a href="#a6bba48a4b1d4834c6617a5af5553be1c">More...</a><br/></td></tr>
<tr class="separator:a6bba48a4b1d4834c6617a5af5553be1c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2019f4bb1e22a8d622ce4d155c934eb0"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpython_1_1CapacitorRouted_1_1RoutMatchedCapacitor.html#a2019f4bb1e22a8d622ce4d155c934eb0">drawCuts</a></td></tr>
<tr class="memdesc:a2019f4bb1e22a8d622ce4d155c934eb0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Draws all required cuts using physical layers :  <a href="#a2019f4bb1e22a8d622ce4d155c934eb0">More...</a><br/></td></tr>
<tr class="separator:a2019f4bb1e22a8d622ce4d155c934eb0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab3fd42d04811b9c88654c0ca0e6e2de7"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpython_1_1CapacitorRouted_1_1RoutMatchedCapacitor.html#ab3fd42d04811b9c88654c0ca0e6e2de7">drawOneCut_vRoutingTrack_HRLayer</a></td></tr>
<tr class="memdesc:ab3fd42d04811b9c88654c0ca0e6e2de7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Draws one cut, in layer <code>cutLayer</code>, in order to connect a vertical routing track, at position <code>cutXMin</code> in metal 2, and a horizontal routing track, at position <code>cutYMin</code> in metal 3.  <a href="#ab3fd42d04811b9c88654c0ca0e6e2de7">More...</a><br/></td></tr>
<tr class="separator:ab3fd42d04811b9c88654c0ca0e6e2de7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a05e49f5537d31e0ab19b8a86eb6e7b1c"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpython_1_1CapacitorRouted_1_1RoutMatchedCapacitor.html#a05e49f5537d31e0ab19b8a86eb6e7b1c">drawCuts_vRoutingTrack_hRoutingTrack</a></td></tr>
<tr class="memdesc:a05e49f5537d31e0ab19b8a86eb6e7b1c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Draws cuts to connect vertical routing tracks in metal 2 and horizontal routing tracks in metal 3.  <a href="#a05e49f5537d31e0ab19b8a86eb6e7b1c">More...</a><br/></td></tr>
<tr class="separator:a05e49f5537d31e0ab19b8a86eb6e7b1c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7d642764cf9e385710751eec3f43f7af"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpython_1_1CapacitorRouted_1_1RoutMatchedCapacitor.html#a7d642764cf9e385710751eec3f43f7af">__stretchTopPlates__</a></td></tr>
<tr class="memdesc:a7d642764cf9e385710751eec3f43f7af"><td class="mdescLeft">&#160;</td><td class="mdescRight">Iteratively performs top plates stretching for the capacitor matrix.  <a href="#a7d642764cf9e385710751eec3f43f7af">More...</a><br/></td></tr>
<tr class="separator:a7d642764cf9e385710751eec3f43f7af"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a57eade928345587b01420a05be475a8f"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpython_1_1CapacitorRouted_1_1RoutMatchedCapacitor.html#a57eade928345587b01420a05be475a8f">__stretchTopPlateCompactCap__</a></td></tr>
<tr class="memdesc:a57eade928345587b01420a05be475a8f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Draws vertical stretched layers for a given elementary capacitor.  <a href="#a57eade928345587b01420a05be475a8f">More...</a><br/></td></tr>
<tr class="separator:a57eade928345587b01420a05be475a8f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1077752f46c512f70377cc60bd772034"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpython_1_1CapacitorRouted_1_1RoutMatchedCapacitor.html#a1077752f46c512f70377cc60bd772034">__setStretchingDySourceDyTarget__</a></td></tr>
<tr class="memdesc:a1077752f46c512f70377cc60bd772034"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the abcissas of the extremities of the vertical stretching to be applied to capacitor's top plates for a given elementary capacitor in the matrix.  <a href="#a1077752f46c512f70377cc60bd772034">More...</a><br/></td></tr>
<tr class="separator:a1077752f46c512f70377cc60bd772034"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaaf2e610688441a439b8a3624e1393b9"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpython_1_1CapacitorRouted_1_1RoutMatchedCapacitor.html#aaaf2e610688441a439b8a3624e1393b9">__computeConnections__</a></td></tr>
<tr class="memdesc:aaaf2e610688441a439b8a3624e1393b9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes horizontal routing layers source and target abcissas for top and bottom plates connections to its associated routing track.  <a href="#aaaf2e610688441a439b8a3624e1393b9">More...</a><br/></td></tr>
<tr class="separator:aaaf2e610688441a439b8a3624e1393b9"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>Routs two matched capacitors, C1 and C2, drawn in a capacitor matrix. </p>
<p>Connections are put in place with reference to a given matching scheme. Elementary capacitor units are connected to horizontal and vertical routing tracks that represent top plates and bottom plates nets of C1 and C2 . Supported types of capacitors are Poly-Poly and Metal-Metal. Technologycal rules are provided by 350 nm AMS CMOS technology with three-four metal layers. Metal layers that are used for routing are placed similarly to horziontal-vertical (HV) symbolic Alliance CAD tool router, where horizontal metal channels are drawn in metal 2 and the vertical ones are in metal 3. Given a matrix of dimensions <img class="formulaInl" alt="$ R*C $" src="form_11.png"/>, the total number of vertical tracks is <img class="formulaInl" alt="$ 2C+2 $" src="form_12.png"/> equivalent to <img class="formulaInl" alt="$ C+1 $" src="form_13.png"/> couples, ensuring that every elementary capacitor is positioned between four vertical tracks, two from each side. In fact, every adjacent couple of these tracks represent top plates and bottom plates of C1 or C2 as shown in Figure 1. </p>
<div class="image">
<img src="Layout.png" alt="Layout.png"/>
<div class="caption">
Layout</div></div>
<p> An elementary capacitor unit can be a part of C1 or C2 according to the matching scheme. However, to respect common-centroid layout specifications, for C1 and C2 to be equal, the matrix number of colums and number of rows must be both even. Addionnally, the number of elementary capacitors dedicated to C1 must be equal to those dedicated to C2. These two conditions are tested in one of the class methods. An exception is raised if at least one of the two is not respected. </p>
</div><h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a class="anchor" id="ac775ee34451fdfa742b318538164070e"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def __init__ </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>vRTInstance</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>A special method used to customize the class instance to an initial state in which : </p>
<ul>
<li>the class attirbutes describing positions and dimensions of the layout are computed in dedicated class methods,</li>
<li>the attributes related to the capacitor matrix are copied from the <code>CapacitorStack</code> instance.</li>
</ul>
<p>Position and dimensions attributes, also refered by layout variables, in Figure 2, are defined below : </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">device</td><td>The <a class="elRef" doxygen="/dsk/l1/jpc/coriolis-2.x/src/coriolis/hurricane/doc/hurricane/html/hurricane.tag:../hurricane/" href="../hurricane/namespaceHurricane.html">Hurricane</a> AMS device onto which the layout is drawn. </td></tr>
    <tr><td class="paramname">capacitorInstance</td><td>Instance of <code>CapacitorStack</code> class. </td></tr>
    <tr><td class="paramname">capacitor</td><td>A nested list containing the matrix elements, which are <code>CapacitorUnit</code> objects. </td></tr>
    <tr><td class="paramname">matchingScheme</td><td>A nested list, with equal dimensions as <code>capacitor</code> attribute, containing assignements of matrix elementary units to C1 and C2, identified by 1 and 2, respectively. Therefore, <code>self.matchingScheme</code> content is a succession of 1 and 2 values, defined as \ capacitor identifiers. For example, given a matrix of dimensions 2x2, the matching scheme can be <img class="formulaInl" alt="$ [ [1,2], [1,2] ] or [ [2,1], [2,1] ] $" src="form_14.png"/>. The first sub-list dictates that the first elementary capacitor, <img class="formulaInl" alt="$ C_{00} $" src="form_15.png"/>. The second element <img class="formulaInl" alt="$ C_{01} $" src="form_16.png"/> is affected to C2 and so on. An immediate and obvious consequence to this, is that an error is raised if <code>self.matchingSchem</code> and <code>self.capacitor</code> dimensions are not identical or if <code>self.matchingScheme</code> content is different from supported capacitor identifiers, '1' and '2'.</td></tr>
    <tr><td class="paramname">capacitorType</td><td>Supported types of capacitors are MIM and PIP only. An exception is raised otherwise. </td></tr>
    <tr><td class="paramname">abutmentBox</td><td>The matrix's abutment box. </td></tr>
    <tr><td class="paramname">matrxiDim</td><td>The matrix dimensions, also equal to <code>self.matchingScheme</code> nested list dimensions. </td></tr>
    <tr><td class="paramname">abutmentBox_spacing</td><td>The spacing between elementary units in the matrix. It is computed in <code>CapacitorStack</code> and is reloaded in <code><a class="el" href="classpython_1_1CapacitorRouted_1_1RoutMatchedCapacitor.html" title="Routs two matched capacitors, C1 and C2, drawn in a capacitor matrix. ">RoutMatchedCapacitor</a></code>. <code>self.abutmentBox_spacing</code> includes, vertical routing tracks width and minimum allowed spacing between two adjacent ones. </td></tr>
    <tr><td class="paramname">hRoutingLayer_width</td><td>The width of horizontal routing layers in metal 2, which connect capacitors plates to vertical routing tracks. </td></tr>
    <tr><td class="paramname">vRoutingTrack_width</td><td>The width of vertical routing tracks in metal 3, which connects identical nets together ( ie : bottom plates of C1, top plates of C2, bottom plates of C2 and top plates of C2 ). </td></tr>
    <tr><td class="paramname">hRoutingTrack_width</td><td>The width of horizontal routing tracks in metal 2, which connect identical vertical routing tracks together. </td></tr>
    <tr><td class="paramname">minSpacing_hRoutingTrack</td><td>Minimum spacing between horizontal routing tracks. Wide metal 2 specifications are considered since metal 2 dimensions may exceed 10 <img class="formulaInl" alt="$ m$" src="form_17.png"/>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section user"><dt>Remark:</dt><dd>For more information about wide metal specifications, refer to ENG-183_rev8.pdf technology manual.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">minimumPosition</td><td>The ordinate of the top plate's routing layer's bottom extremity after stretching. </td></tr>
    <tr><td class="paramname">maximumPosition</td><td>The ordinate of the top plate's routing layer's top extremity, also equivalent to the top plate's top extremity. </td></tr>
    <tr><td class="paramname">vRoutingTrackXCenter</td><td>A nested list of ordered dictionaries, with dimensions equal to <code>self.matrixDim</code>, containing abcissas of vertical routing tracks. All sub-lists' lengths are identical and are equal to 2. The first and second elements describe position of top plate track and bottom plate track, respectively. For example, given a matrix of dimensions 2x2, <code>self.vRoutingTrackXCenter</code> can be [[0, 2], [4,6], [8,10]] <img class="formulaInl" alt="$ \mu m$" src="form_18.png"/>. Elements of this nested list have particular indexing as described in Figure 2.</td></tr>
    <tr><td class="paramname">hRoutingtrackYCenter</td><td>A nested dictonary containing two keys, <code>topTracks</code> and <code>bottomTracks</code>. Each key contains as value a dictionary describing centers' ordinates of four parallel horizontal tracks. The reason why four tracks are needed on top and bottom positions of the matrix is that four nets are used, two for every capacitor <code>Ci</code>, were <code>i</code> is in [1,2]. </td></tr>
    <tr><td class="paramname">hRoutingLayerYCenter</td><td>A nested dicitonary containing two keys, <code>top</code> and <code>bottom</code>. Each key contains as value a dictionary describing centers' ordinates of horizontal routing layers. </td></tr>
    <tr><td class="paramname">vRoutingTrackDict</td><td>A dictionary of routing tracks top and bottom extremities ordinates. </td></tr>
    <tr><td class="paramname">topPlateStretching</td><td>Since not only the same metal 2 layer is used to draw top/bottom plates connections to vertical tracks but also the two plates are superimposed, the top plate's routing tracks is stretched. <code>self.topPlateStretching</code> is therefore the length added to top plate's routing layer in order to avoid short circuits between top and bottom plates routing to vertical tracks since the same metal is used for both. </td></tr>
  </table>
  </dd>
</dl>

<p>References RoutMatchedCapacitor.capacitor, CapacitorStack.dummyRing, RoutMatchedCapacitor.dummyRing, RoutMatchedCapacitor.dummyRingCapacitor, RoutMatchedCapacitor.hRoutingLayer_width, RoutMatchedCapacitor.hRoutingLayerYCenter, RoutMatchedCapacitor.hRoutingTrack_width, RoutMatchedCapacitor.hRoutingtrackYCenter, CapacitorStack.matrixDim, VerticalRoutingTracks.matrixDim, RoutMatchedCapacitor.maximumPosition, RoutMatchedCapacitor.minimumPosition, RoutMatchedCapacitor.minSpacing_hRoutingTrack, RoutMatchedCapacitor.topPlateStretching, and RoutMatchedCapacitor.vRTInstance.</p>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a class="anchor" id="a15ec3e3156133327b307cd0e4b75f22c"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def route </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>bbMode</em> = <code>False</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Draws the complete layout given the capacitor matrix. </p>
<p><code>route</code> method is succession of calls to user-defined methods inside a newly created <code>Updatesession</code>. The following tasks are excecuted :</p>
<ol type="1">
<li>A nex <code>UpdateSession</code> is created,</li>
<li>all required physical layers are loaded,</li>
<li>technology rules are defined according to capacitor type,</li>
<li>layout dimension parameters are computed,</li>
<li>routing tracks and layers are drawn,</li>
<li>top plates are stretched,</li>
<li>all required cuts are drawn,</li>
<li>The <code>UpdateSession</code> is closed.</li>
</ol>
<p>Meanwhile, an exception is raised when the entered <code>capacitor</code> is not a capacitor matrix or if the capacitor type is unsupported. </p>

<p>References <a class="el" href="classpython_1_1CapacitorRouted_1_1RoutMatchedCapacitor.html#a7d642764cf9e385710751eec3f43f7af">RoutMatchedCapacitor.__stretchTopPlates__()</a>, RoutMatchedCapacitor.capacitor, <a class="el" href="classpython_1_1CapacitorRouted_1_1RoutMatchedCapacitor.html#a20b46b43488cc58c302b123a89299d85">RoutMatchedCapacitor.computeDimensions()</a>, CapacitorUnit.computeDimensions(), <a class="el" href="classpython_1_1Stack_1_1Stack.html#a20b46b43488cc58c302b123a89299d85">Stack.computeDimensions()</a>, <a class="el" href="classpython_1_1CapacitorRouted_1_1RoutMatchedCapacitor.html#a2019f4bb1e22a8d622ce4d155c934eb0">RoutMatchedCapacitor.drawCuts()</a>, RoutMatchedCapacitor.drawDummyRing_hRTracks_Cuts(), <a class="el" href="classpython_1_1CapacitorRouted_1_1RoutMatchedCapacitor.html#a6bba48a4b1d4834c6617a5af5553be1c">RoutMatchedCapacitor.drawHRLayers()</a>, <a class="el" href="classpython_1_1CapacitorRouted_1_1RoutMatchedCapacitor.html#afbe39494b52b035fe3efdb0ddb896f69">RoutMatchedCapacitor.drawHRoutingTracks()</a>, CapacitorStack.dummyRing, RoutMatchedCapacitor.dummyRing, RoutMatchedCapacitor.dummyRingCapacitor, VerticalRoutingTracks.getVTrackYMax(), VerticalRoutingTracks.getVTrackYMin(), CapacitorUnit.hpitch, RoutMatchedCapacitor.hRoutingtrackYCenter, VerticalRoutingTracks.matchingScheme, CapacitorStack.matchingScheme, CapacitorStack.matrixDim, VerticalRoutingTracks.matrixDim, RoutMatchedCapacitor.maximumPosition, CapacitorUnit.metal3Width, RoutMatchedCapacitor.minimumPosition, VerticalRoutingTracks.nets, CapacitorStack.nets, RoutMatchedCapacitor.routeDummyRing(), RoutMatchedCapacitor.routeLeftAndRightSides(), RoutMatchedCapacitor.routeTopOrBottomSide(), <a class="el" href="classpython_1_1CapacitorRouted_1_1RoutMatchedCapacitor.html#ae361a87f8ad999bb5f1b9851773f481b">RoutMatchedCapacitor.setLayers()</a>, CapacitorStack.setRules(), <a class="el" href="classpython_1_1CapacitorUnit_1_1CapacitorUnit.html#a3b578035b1559391931dade7c2508105">CapacitorUnit.setRules()</a>, <a class="el" href="classpython_1_1CapacitorRouted_1_1RoutMatchedCapacitor.html#a3b578035b1559391931dade7c2508105">RoutMatchedCapacitor.setRules()</a>, CapacitorUnit.vpitch, VerticalRoutingTracks.vRoutingTrack_width, CapacitorStack.vRoutingTrack_width, and RoutMatchedCapacitor.vRoutingTrackXCenter.</p>

</div>
</div>
<a class="anchor" id="a3b578035b1559391931dade7c2508105"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def setRules </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Defines technology rules used to draw the layout. </p>
<p>Some of the rules, namely those describing routing layers and tracks are applicable for both MIM and PIP capacitors. However, cuts rules are different.</p>
<dl class="section user"><dt>Remark:</dt><dd>All <code>CapacitorStack</code> class rules are also reloaded in this class. An exception is raised if the entered capacitor type is unsupported.</dd></dl>
<dl class="section return"><dt>Returns</dt><dd>a dictionary with rules labels as keys and rules content as values. </dd></dl>

<p>References CapacitorStack.capacitorType, CapacitorUnit.capacitorType, RoutMatchedCapacitor.capacitorType, CapacitorStack.minEnclosure_hRoutingLayer_topPlate_cut, RoutMatchedCapacitor.minEnclosure_hRoutingLayer_topPlate_cut, RoutMatchedCapacitor.minSpacing_hRoutingLayer, RoutMatchedCapacitor.minSpacing_hRoutingLayer_topPlate_cut, RoutMatchedCapacitor.minSpacing_hRoutingLayer_vRoutingTrack_cut, RoutMatchedCapacitor.minSpacing_hRoutingTrackCut, CapacitorStack.minSpacing_vRoutingTrackCut, RoutMatchedCapacitor.minSpacing_vRoutingTrackCut, CapacitorStack.minWidth_hRoutingLayer_topPlate_cut, and RoutMatchedCapacitor.minWidth_hRoutingLayer_topPlate_cut.</p>

<p>Referenced by <a class="el" href="classpython_1_1CapacitorRouted_1_1RoutMatchedCapacitor.html#a15ec3e3156133327b307cd0e4b75f22c">RoutMatchedCapacitor.route()</a>, and <a class="el" href="classpython_1_1CapacitorVRTracks_1_1VerticalRoutingTracks.html#a3b578035b1559391931dade7c2508105">VerticalRoutingTracks.setRules()</a>.</p>

</div>
</div>
<a class="anchor" id="ae361a87f8ad999bb5f1b9851773f481b"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def setLayers </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Defines all physical layers used to draw the layout. </p>
<p>Layers are loaded using <code>DataBase</code> API. The same routing layers are used for both capacitor types except cuts layers that connect top plates to vertical routing tracks. Basicaly, metal 2, meta 3, cut 1 and cut 2 are the ones defined. </p>
<dl class="section return"><dt>Returns</dt><dd>a dictionary composed of layers labels as keys and layers as values. </dd></dl>

<p>References CapacitorStack.capacitorType, CapacitorUnit.capacitorType, RoutMatchedCapacitor.capacitorType, CapacitorStack.dummyRing, and RoutMatchedCapacitor.dummyRing.</p>

<p>Referenced by <a class="el" href="classpython_1_1CapacitorRouted_1_1RoutMatchedCapacitor.html#a15ec3e3156133327b307cd0e4b75f22c">RoutMatchedCapacitor.route()</a>.</p>

</div>
</div>
<a class="anchor" id="a20b46b43488cc58c302b123a89299d85"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def computeDimensions </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>bbMode</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Computes, through simple instructions and functions calls, layout variables detailed in Figure 2. </p>

<p>References CapacitorStack.abutmentBox_spacing, RoutMatchedCapacitor.abutmentBox_spacing, VerticalRoutingTracks.capacitorsNumber, CapacitorStack.capacitorsNumber, RoutMatchedCapacitor.computeBondingBoxDimInbbMode(), <a class="el" href="classpython_1_1CapacitorRouted_1_1RoutMatchedCapacitor.html#a0d90b75abe0f4ce0f0b9b1b405462300">RoutMatchedCapacitor.computeHRLayerYCenter()</a>, <a class="el" href="classpython_1_1CapacitorRouted_1_1RoutMatchedCapacitor.html#ab00cae047369eb93c10e44e316fa991b">RoutMatchedCapacitor.computeHRoutingTrackYCenter()</a>, RoutMatchedCapacitor.hRoutingLayer_width, CapacitorStack.matrixDim, VerticalRoutingTracks.matrixDim, RoutMatchedCapacitor.maximumPosition, CapacitorStack.minEnclosure_hRoutingLayer_topPlate_cut, RoutMatchedCapacitor.minEnclosure_hRoutingLayer_topPlate_cut, VerticalRoutingTracks.minEnclosure_hRoutingLayer_vRoutingTrack_cut, RoutMatchedCapacitor.minimumPosition, VerticalRoutingTracks.minWidth_hRoutingLayer, CapacitorStack.minWidth_hRoutingLayer_topPlate_cut, RoutMatchedCapacitor.minWidth_hRoutingLayer_topPlate_cut, VerticalRoutingTracks.minWidth_hRoutingLayer_vRoutingTrack_cut, RoutMatchedCapacitor.vRoutingTrack_spacing, VerticalRoutingTracks.vRoutingTrack_width, CapacitorStack.vRoutingTrack_width, RoutMatchedCapacitor.vRoutingTrackDict, and RoutMatchedCapacitor.vRoutingTrackXCenter.</p>

<p>Referenced by <a class="el" href="classpython_1_1CapacitorRouted_1_1RoutMatchedCapacitor.html#a15ec3e3156133327b307cd0e4b75f22c">RoutMatchedCapacitor.route()</a>.</p>

</div>
</div>
<a class="anchor" id="ab00cae047369eb93c10e44e316fa991b"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def computeHRoutingTrackYCenter </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Computes centers' ordinates of the eight horizontal routing tracks. </p>
<p>The tracks include four on top and four on bottom of the matrix. To do the computations, fist, center of the first bottom or top track, given in Figure 2, is computed. Then, all adjacent three centers are deduced by simples translation of the first one. Translation quantity is equal to the sum of distance between adjacent routing tracks, self.hRoutingTracks_spacing, and half width of the routing track itself, <code>self.hRoutingTrack_width</code>. </p>

<p>References RoutMatchedCapacitor.__setPlatesIds__(), CapacitorUnit.hpitch, RoutMatchedCapacitor.hRoutingtrackYCenter, RoutMatchedCapacitor.maximumPosition, and RoutMatchedCapacitor.minimumPosition.</p>

<p>Referenced by <a class="el" href="classpython_1_1CapacitorRouted_1_1RoutMatchedCapacitor.html#a20b46b43488cc58c302b123a89299d85">RoutMatchedCapacitor.computeDimensions()</a>.</p>

</div>
</div>
<a class="anchor" id="a0d90b75abe0f4ce0f0b9b1b405462300"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def computeHRLayerYCenter </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sets the stretching value of top plates. </p>
<p>Then iteratively computes the centers of horizontal routing layer regarding top and bottom plates. </p>

<p>References RoutMatchedCapacitor.__findPossibleShortCircuits__(), <a class="el" href="classpython_1_1CapacitorVRTracks_1_1VerticalRoutingTracks.html#a42e286a4157e638ddb3d96ce7c47dece">VerticalRoutingTracks.__setStretching__()</a>, <a class="el" href="classpython_1_1CapacitorRouted_1_1RoutMatchedCapacitor.html#a1077752f46c512f70377cc60bd772034">RoutMatchedCapacitor.__setStretchingDySourceDyTarget__()</a>, RoutMatchedCapacitor.bondingBox, RoutMatchedCapacitor.capacitor, RoutMatchedCapacitor.hRoutingLayer_width, RoutMatchedCapacitor.hRoutingLayerYCenter, RoutMatchedCapacitor.hRoutingTrack_width, RoutMatchedCapacitor.hRoutingtrackYCenter, CapacitorStack.matrixDim, VerticalRoutingTracks.matrixDim, RoutMatchedCapacitor.minSpacing_hRoutingLayer, RoutMatchedCapacitor.topPlateStretching, VerticalRoutingTracks.vRoutingTrack_width, CapacitorStack.vRoutingTrack_width, and RoutMatchedCapacitor.vRoutingTrackXCenter.</p>

<p>Referenced by <a class="el" href="classpython_1_1CapacitorRouted_1_1RoutMatchedCapacitor.html#a20b46b43488cc58c302b123a89299d85">RoutMatchedCapacitor.computeDimensions()</a>.</p>

</div>
</div>
<a class="anchor" id="afbe39494b52b035fe3efdb0ddb896f69"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def drawHRoutingTracks </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>routingTracksLayer</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Iteratively draws horizontal routing tracks on top and bottom positions of the matrix using physical layer <code>routingTracksLayer</code>. </p>

<p>References RoutMatchedCapacitor.hRoutingTrack_width, RoutMatchedCapacitor.hRoutingtrackYCenter, VerticalRoutingTracks.nets, CapacitorStack.nets, and RoutMatchedCapacitor.vRoutingTrackXCenter.</p>

<p>Referenced by <a class="el" href="classpython_1_1CapacitorRouted_1_1RoutMatchedCapacitor.html#a15ec3e3156133327b307cd0e4b75f22c">RoutMatchedCapacitor.route()</a>.</p>

</div>
</div>
<a class="anchor" id="a6bba48a4b1d4834c6617a5af5553be1c"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def drawHRLayers </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>xPlateRLayer</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Iteratively draws the horizontal routing layers starting with bottom left elementary capacitor <img class="formulaInl" alt="$ C_{00} $" src="form_15.png"/>. </p>

<p>References <a class="el" href="classpython_1_1CapacitorRouted_1_1RoutMatchedCapacitor.html#aaaf2e610688441a439b8a3624e1393b9">RoutMatchedCapacitor.__computeConnections__()</a>, RoutMatchedCapacitor.hRoutingLayer_width, RoutMatchedCapacitor.hRoutingLayerYCenter, VerticalRoutingTracks.matchingScheme, CapacitorStack.matchingScheme, VerticalRoutingTracks.matrixDim, CapacitorStack.matrixDim, VerticalRoutingTracks.nets, and CapacitorStack.nets.</p>

<p>Referenced by <a class="el" href="classpython_1_1CapacitorRouted_1_1RoutMatchedCapacitor.html#a15ec3e3156133327b307cd0e4b75f22c">RoutMatchedCapacitor.route()</a>.</p>

</div>
</div>
<a class="anchor" id="a2019f4bb1e22a8d622ce4d155c934eb0"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def drawCuts </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>layer_hRTrack_hRLayer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>layer_tracksCut</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>layer_topPlateCut</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Draws all required cuts using physical layers : </p>
<ul>
<li><code>layer_hRTrack_hRLayer</code> to connect bottom plates to vertical routing tracks,</li>
<li><code>layer_tracksCut</code> to connect vertical routing tracks to horizontal ones,</li>
<li><code>layer_topPlateCut</code> to connect top plates to vertical routing tracks. ALso in <code>drawCuts</code>, nUmber of maximum cuts number on every layer is computed and cuts enclosure is adjusted according to layer's width. </li>
</ul>

<p>References RoutMatchedCapacitor.__setPlatesLabels__(), VerticalRoutingTracks.capacitorIds, VerticalRoutingTracks.capacitorsNumber, CapacitorStack.capacitorsNumber, RoutMatchedCapacitor.drawCuts_stretchedTopPlate(), RoutMatchedCapacitor.drawCuts_vRoutingTrack_HRLayer(), <a class="el" href="classpython_1_1CapacitorRouted_1_1RoutMatchedCapacitor.html#a05e49f5537d31e0ab19b8a86eb6e7b1c">RoutMatchedCapacitor.drawCuts_vRoutingTrack_hRoutingTrack()</a>, <a class="el" href="classpython_1_1CapacitorRouted_1_1RoutMatchedCapacitor.html#ab3fd42d04811b9c88654c0ca0e6e2de7">RoutMatchedCapacitor.drawOneCut_vRoutingTrack_HRLayer()</a>, RoutMatchedCapacitor.hRoutingLayerYCenter, VerticalRoutingTracks.matchingScheme, CapacitorStack.matchingScheme, VerticalRoutingTracks.matrixDim, CapacitorStack.matrixDim, CapacitorStack.minEnclosure_vRoutingTrackCut, RoutMatchedCapacitor.minSpacing_hRoutingTrackCut, CapacitorStack.minSpacing_vRoutingTrackCut, RoutMatchedCapacitor.minSpacing_vRoutingTrackCut, VerticalRoutingTracks.minWidth_hRoutingTrackCut, CapacitorStack.minWidth_vRoutingTrackCut, VerticalRoutingTracks.nets, CapacitorStack.nets, VerticalRoutingTracks.vRoutingTrack_width, CapacitorStack.vRoutingTrack_width, and RoutMatchedCapacitor.vRoutingTrackXCenter.</p>

<p>Referenced by <a class="el" href="classpython_1_1CapacitorRouted_1_1RoutMatchedCapacitor.html#a15ec3e3156133327b307cd0e4b75f22c">RoutMatchedCapacitor.route()</a>.</p>

</div>
</div>
<a class="anchor" id="ab3fd42d04811b9c88654c0ca0e6e2de7"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def drawOneCut_vRoutingTrack_HRLayer </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>net</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>cutLayer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>cutXMin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>cutYMin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>cutNumber</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Draws one cut, in layer <code>cutLayer</code>, in order to connect a vertical routing track, at position <code>cutXMin</code> in metal 2, and a horizontal routing track, at position <code>cutYMin</code> in metal 3. </p>

<p>References RoutMatchedCapacitor.minSpacing_hRoutingLayer_vRoutingTrack_cut, and VerticalRoutingTracks.minWidth_hRoutingLayer_vRoutingTrack_cut.</p>

<p>Referenced by <a class="el" href="classpython_1_1CapacitorRouted_1_1RoutMatchedCapacitor.html#a2019f4bb1e22a8d622ce4d155c934eb0">RoutMatchedCapacitor.drawCuts()</a>.</p>

</div>
</div>
<a class="anchor" id="a05e49f5537d31e0ab19b8a86eb6e7b1c"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def drawCuts_vRoutingTrack_hRoutingTrack </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>cutLayer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>cutNumber</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>enclosure_cut</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Draws cuts to connect vertical routing tracks in metal 2 and horizontal routing tracks in metal 3. </p>

<p>References RoutMatchedCapacitor.__setPlatesIds__(), RoutMatchedCapacitor.capacitor, RoutMatchedCapacitor.dummyRingCapacitor, RoutMatchedCapacitor.hRoutingLayerYCenter, RoutMatchedCapacitor.hRoutingtrackYCenter, VerticalRoutingTracks.matchingScheme, CapacitorStack.matchingScheme, VerticalRoutingTracks.matrixDim, CapacitorStack.matrixDim, CapacitorStack.minEnclosure_hRoutingLayer_topPlate_cut, RoutMatchedCapacitor.minEnclosure_hRoutingLayer_topPlate_cut, CapacitorStack.minEnclosure_vRoutingTrackCut, RoutMatchedCapacitor.minSpacing_hRoutingLayer_topPlate_cut, RoutMatchedCapacitor.minSpacing_hRoutingTrackCut, CapacitorStack.minSpacing_vRoutingTrackCut, RoutMatchedCapacitor.minSpacing_vRoutingTrackCut, CapacitorStack.minWidth_hRoutingLayer_topPlate_cut, RoutMatchedCapacitor.minWidth_hRoutingLayer_topPlate_cut, VerticalRoutingTracks.minWidth_hRoutingTrackCut, CapacitorStack.minWidth_vRoutingTrackCut, VerticalRoutingTracks.nets, CapacitorStack.nets, VerticalRoutingTracks.vRoutingTrack_width, CapacitorStack.vRoutingTrack_width, and RoutMatchedCapacitor.vRoutingTrackXCenter.</p>

<p>Referenced by <a class="el" href="classpython_1_1CapacitorRouted_1_1RoutMatchedCapacitor.html#a2019f4bb1e22a8d622ce4d155c934eb0">RoutMatchedCapacitor.drawCuts()</a>.</p>

</div>
</div>
<a class="anchor" id="a7d642764cf9e385710751eec3f43f7af"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def __stretchTopPlates__ </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>capacitor</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>rlayer</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Iteratively performs top plates stretching for the capacitor matrix. </p>
<p>Vertical segments are connected to top plate routing layer. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">capacitor</td><td>Capacitor matrix. </td></tr>
    <tr><td class="paramname">rlayer</td><td>Layer of the drawn vertical rectangle. </td></tr>
  </table>
  </dd>
</dl>

<p>References <a class="el" href="classpython_1_1CapacitorRouted_1_1RoutMatchedCapacitor.html#a57eade928345587b01420a05be475a8f">RoutMatchedCapacitor.__stretchTopPlateCompactCap__()</a>, VerticalRoutingTracks.matchingScheme, CapacitorStack.matchingScheme, VerticalRoutingTracks.matrixDim, CapacitorStack.matrixDim, VerticalRoutingTracks.nets, and CapacitorStack.nets.</p>

<p>Referenced by <a class="el" href="classpython_1_1CapacitorRouted_1_1RoutMatchedCapacitor.html#a15ec3e3156133327b307cd0e4b75f22c">RoutMatchedCapacitor.route()</a>.</p>

</div>
</div>
<a class="anchor" id="a57eade928345587b01420a05be475a8f"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def __stretchTopPlateCompactCap__ </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>net</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>capacitor</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>routingLayer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>j</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Draws vertical stretched layers for a given elementary capacitor. </p>

<p>References <a class="el" href="classpython_1_1CapacitorRouted_1_1RoutMatchedCapacitor.html#a1077752f46c512f70377cc60bd772034">RoutMatchedCapacitor.__setStretchingDySourceDyTarget__()</a>, and RoutMatchedCapacitor.topPlateStretching.</p>

<p>Referenced by <a class="el" href="classpython_1_1CapacitorRouted_1_1RoutMatchedCapacitor.html#a7d642764cf9e385710751eec3f43f7af">RoutMatchedCapacitor.__stretchTopPlates__()</a>.</p>

</div>
</div>
<a class="anchor" id="a1077752f46c512f70377cc60bd772034"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def __setStretchingDySourceDyTarget__ </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>capacitor</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>deltay</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sets the abcissas of the extremities of the vertical stretching to be applied to capacitor's top plates for a given elementary capacitor in the matrix. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">capacitor</td><td>.values() Elementary unit capacitor. </td></tr>
    <tr><td class="paramname">deltay</td><td>Stretching value. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A list that contains <code>dySource</code> and  as top extremity and bottom extermity, respectively. </dd></dl>

<p>Referenced by <a class="el" href="classpython_1_1CapacitorRouted_1_1RoutMatchedCapacitor.html#a57eade928345587b01420a05be475a8f">RoutMatchedCapacitor.__stretchTopPlateCompactCap__()</a>, and <a class="el" href="classpython_1_1CapacitorRouted_1_1RoutMatchedCapacitor.html#a0d90b75abe0f4ce0f0b9b1b405462300">RoutMatchedCapacitor.computeHRLayerYCenter()</a>.</p>

</div>
</div>
<a class="anchor" id="aaaf2e610688441a439b8a3624e1393b9"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def __computeConnections__ </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>i</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>j</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>capacitorIdentifier</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Computes horizontal routing layers source and target abcissas for top and bottom plates connections to its associated routing track. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">(i,j)</td><td>row and column indexes, respectively, in the matrix which describe the elementary capacitor position in the matrix. </td></tr>
    <tr><td class="paramname">capacitorIdentifier</td><td>equal to '1' if C1 and '2' if C2. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A nested dicitionary. The overal dictionary is composed of keys equal to <code>topPlate</code> and  bottomPlate and values equal to sub-dictionaries. The sub-dictionaries, are in their turn composed of two keys standing for the abcissa of the source and the abcissa of the target. </dd></dl>
<dl class="section user"><dt>Remark:</dt><dd>Naturally, an exception is raised if an unsupported capacitor identifier is given. </dd></dl>

<p>References RoutMatchedCapacitor.__findHRLDyTrarget__(), RoutMatchedCapacitor.__isCapacitorAdummy__(), RoutMatchedCapacitor.__setPlatesLabels__(), RoutMatchedCapacitor.capacitor, VerticalRoutingTracks.capacitorIds, VerticalRoutingTracks.capacitorsNumber, CapacitorStack.capacitorsNumber, CapacitorStack.dummyElement, RoutMatchedCapacitor.dummyElement, CapacitorStack.dummyRing, RoutMatchedCapacitor.dummyRing, VerticalRoutingTracks.matchingScheme, CapacitorStack.matchingScheme, VerticalRoutingTracks.matrixDim, CapacitorStack.matrixDim, VerticalRoutingTracks.nets, CapacitorStack.nets, VerticalRoutingTracks.vRoutingTrack_width, CapacitorStack.vRoutingTrack_width, RoutMatchedCapacitor.vRoutingTrackXCenter, and RoutMatchedCapacitor.vRTsDistribution.</p>

<p>Referenced by <a class="el" href="classpython_1_1CapacitorRouted_1_1RoutMatchedCapacitor.html#a6bba48a4b1d4834c6617a5af5553be1c">RoutMatchedCapacitor.drawHRLayers()</a>.</p>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li>CapacitorRouted.py</li>
</ul>
</div><!-- contents -->
    <br>
    <hr>
    <table class="footer1">
      <tr>
        <td class="LFooter"><small>Generated by doxygen 1.8.5 on Thu Mar 19 2020</small></td>
        <td class="RFooter"><a href='#pagetop'><small>Return to top of page</small></a></td>
      </tr>
    </table>
    <table class="footer2">
      <tr>
        <td class="LFooter">Oroshi - Analog Devices Layouts</td>
        <td class="RFooter"><small>Copyright &#169; 2018-2018 UPMC. All rights reserved</small></td>
      </tr>
    </table>
  </body>
</html>
